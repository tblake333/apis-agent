#!/usr/bin/env python3
"""
Simple test runner command 't' for the probe application.

Usage:
    t <test_name>                    # Run specific test method
    t <TestClass>                    # Run all tests in a class
    t <module_path>                  # Run all tests in a module
    t <module_path>.<TestClass>      # Run specific test class in module
    t <module_path>.<TestClass>.<test_method>  # Run specific test method

Examples:
    t test_ensure_clean_slate_empty
    t TestDatabaseManager
    t tests.test_database_manager
    t tests.test_database_manager.TestDatabaseManager
    t tests.test_database_manager.TestDatabaseManager.test_ensure_clean_slate_empty
"""
import sys
import os
import subprocess
from pathlib import Path


def find_test_file(test_name):
    """Find the test file that contains the given test name."""
    probe_dir = Path(__file__).parent
    
    # If it's already a module path, use it directly
    if test_name.startswith("probe.") or test_name.startswith("tests."):
        return test_name
    
    # Search for test files recursively throughout the project
    for test_file in probe_dir.rglob("test_*.py"):
        try:
            with open(test_file, 'r') as f:
                content = f.read()
                if test_name in content:
                    # Convert to module path relative to probe directory
                    relative_path = test_file.relative_to(probe_dir)
                    module_parts = list(relative_path.parts)
                    module_parts[-1] = module_parts[-1].replace('.py', '')  # Remove .py extension
                    module_name = '.'.join(module_parts)
                    return module_name
        except Exception:
            continue
    
    return None


def build_pytest_command(test_identifier):
    """Build the pytest command for the given test identifier."""
    # Change to the probe directory (find it relative to this script)
    script_path = Path(__file__).resolve()
    probe_dir = script_path.parent
    os.chdir(probe_dir)
    
    # Build the test path and arguments
    cmd = [sys.executable, "-m", "pytest", "-v", "--tb=short", "--color=yes"]
    
    # Check if it's a module path (contains dots)
    if "." in test_identifier:
        # Remove probe. prefix if present
        if test_identifier.startswith("probe."):
            test_identifier = test_identifier[6:]  # Remove "probe."
        
        # Check if this looks like a class or method reference
        # If it ends with a class name (starts with capital) or method name (starts with lowercase)
        parts = test_identifier.split(".")
        
        # Find where the file path ends and class/method names begin
        file_parts = []
        class_method_parts = []
        
        for i, part in enumerate(parts):
            # If this part starts with capital letter, it's likely a class name
            # Only treat lowercase parts as methods if they come after a class name
            if part[0].isupper():
                class_method_parts = parts[i:]
                break
            else:
                file_parts.append(part)
        
        if file_parts:
            # Build the file path
            file_path = "/".join(file_parts) + ".py"
            
            if class_method_parts:
                # Add class/method parts with :: separators
                pytest_path = f"{file_path}::{'::'.join(class_method_parts)}"
                cmd.append(pytest_path)
            else:
                cmd.append(file_path)
        else:
            # All parts are file path parts
            file_path = "/".join(parts) + ".py"
            cmd.append(file_path)
    else:
        # Try to find the test file
        found_module = find_test_file(test_identifier)
        if found_module:
            # Use pattern matching to run only the specific test
            test_path = f"{found_module.replace('tests.', 'tests/')}.py"
            cmd.append(test_path)
            cmd.extend(["-k", test_identifier])
        else:
            # Use pattern matching for test names across all tests
            cmd.append("tests/")
            cmd.extend(["-k", test_identifier])
    
    return cmd


def run_test(test_identifier):
    """Run the specified test."""
    cmd = build_pytest_command(test_identifier)
    
    print(f"Running test: {test_identifier}")
    print(f"Command: {' '.join(cmd)}")
    print("-" * 50)
    
    try:
        result = subprocess.run(cmd, check=True)
        print("\n" + "=" * 50)
        print("✅ Test passed!")
        return 0
    except subprocess.CalledProcessError as e:
        print("\n" + "=" * 50)
        print(f"❌ Test failed with exit code {e.returncode}")
        return e.returncode
    except FileNotFoundError:
        print("❌ pytest not found. Please install it with: pip install pytest")
        return 1


def show_help():
    """Show help information."""
    print(__doc__)
    print("\nAvailable test files:")
    probe_dir = Path(__file__).parent
    test_files = []
    for test_file in sorted(probe_dir.rglob("test_*.py")):
        relative_path = test_file.relative_to(probe_dir)
        module_parts = list(relative_path.parts)
        module_parts[-1] = module_parts[-1].replace('.py', '')  # Remove .py extension
        module_name = '.'.join(module_parts)
        test_files.append(module_name)
    
    for test_file in sorted(test_files):
        print(f"  - {test_file}")
    
    print("\nExamples:")
    print("  t test_ensure_clean_slate_empty")
    print("  t TestDatabaseManager")
    print("  t tests.test_database_manager")
    print("  t tests.test_database_manager.TestDatabaseManager")
    print("  t tests.test_database_manager.TestDatabaseManager.test_ensure_clean_slate_empty")


def main():
    """Main function."""
    if len(sys.argv) < 2:
        show_help()
        return 1
    
    test_identifier = sys.argv[1]
    
    if test_identifier in ["-h", "--help", "help"]:
        show_help()
        return 0
    
    return run_test(test_identifier)


if __name__ == "__main__":
    sys.exit(main())
